#!/usr/bin/env python3
"""
Export functionality for Network Designer
"""

import xml.etree.ElementTree as ET
from xml.dom import minidom
from typing import Dict, List
from models import NetworkDevice, NetworkProject, DeviceType, OSType


class TerraformExporter:
    """Export network configuration to Terraform"""
    
    @staticmethod
    def export(project: NetworkProject) -> str:
        """Generate Terraform configuration for Docker"""
        tf = []
        
        # Header
        tf.append("# Terraform Docker Network Configuration")
        tf.append(f"# Project: {project.name}")
        tf.append(f"# Generated by Network Designer v{project.version}")
        tf.append("")
        tf.append("terraform {")
        tf.append("  required_version = \">= 1.0\"")
        tf.append("  required_providers {")
        tf.append("    docker = {")
        tf.append('      source  = "kreuzwerker/docker"')
        tf.append('      version = "~> 3.0"')
        tf.append("    }")
        tf.append("  }")
        tf.append("}")
        tf.append("")
        tf.append('provider "docker" {')
        tf.append('  host = "unix:///var/run/docker.sock"')
        tf.append("}")
        tf.append("")
        
        # Collect all networks
        networks = set()
        for device in project.devices.values():
            networks.update(device.networks)
        
        # Create Docker networks
        tf.append("# Docker Networks")
        for network in sorted(networks):
            safe_name = TerraformExporter._sanitize_name(network)
            tf.append(f'resource "docker_network" "{safe_name}_network" {{')
            tf.append(f'  name   = "{network}"')
            tf.append('  driver = "bridge"')
            tf.append('  ipam_config {')
            tf.append('    subnet  = "172.20.0.0/16"')
            tf.append('    gateway = "172.20.0.1"')
            tf.append('  }')
            tf.append("}")
            tf.append("")
        
        # Create containers for devices
        tf.append("# Docker Containers")
        for device in project.devices.values():
            if device.type in [DeviceType.COMPUTER, DeviceType.DATABASE]:
                tf.extend(TerraformExporter._generate_container(device))
        
        # Outputs
        tf.append("# Outputs")
        for device in project.devices.values():
            if device.type in [DeviceType.COMPUTER, DeviceType.DATABASE]:
                safe_name = TerraformExporter._sanitize_name(device.name)
                tf.append(f'output "{safe_name}_id" {{')
                tf.append(f'  value       = docker_container.{safe_name}.id')
                tf.append(f'  description = "Container ID for {device.name}"')
                tf.append("}")
                tf.append("")
        
        return '\n'.join(tf)
    
    @staticmethod
    def _generate_container(device: NetworkDevice) -> List[str]:
        """Generate Terraform configuration for a container"""
        tf = []
        safe_name = TerraformExporter._sanitize_name(device.name)
        
        tf.append(f'resource "docker_container" "{safe_name}" {{')
        tf.append(f'  name  = "{device.name}"')
        
        # Determine image
        if device.config:
            if device.config.os == OSType.CUSTOM and device.config.custom_image:
                tf.append(f'  image = "{device.config.custom_image}"')
            else:
                tf.append(f'  image = "{device.config.os.value}"')
        else:
            tf.append('  image = "alpine:latest"')
        
        tf.append('  must_run = true')
        
        # Networks configuration with interfaces
        if device.config and device.config.interfaces:
            for iface in device.config.interfaces:
                if iface.ip_address:
                    for network in device.networks:
                        safe_network = TerraformExporter._sanitize_name(network)
                        tf.append("  networks_advanced {")
                        tf.append(f'    name         = docker_network.{safe_network}_network.name')
                        tf.append(f'    ipv4_address = "{iface.ip_address}"')
                        tf.append("  }")
                        break
        else:
            # Default network configuration
            for network in device.networks:
                safe_network = TerraformExporter._sanitize_name(network)
                tf.append("  networks_advanced {")
                tf.append(f'    name = docker_network.{safe_network}_network.name')
                tf.append("  }")
        
        if device.config:
            # Port mappings
            for port_mapping in device.config.ports:
                if ':' in port_mapping:
                    external, internal = port_mapping.split(':')
                    tf.append("  ports {")
                    tf.append(f'    internal = {internal}')
                    tf.append(f'    external = {external}')
                    tf.append('    protocol = "tcp"')
                    tf.append("  }")
            
            # Environment variables
            if device.config.environment_vars:
                tf.append("  env = [")
                for key, value in device.config.environment_vars.items():
                    tf.append(f'    "{key}={value}",')
                tf.append("  ]")
            
            # Volumes
            if device.config.storage_volume and ':' in device.config.storage_volume:
                host_path, container_path = device.config.storage_volume.split(':', 1)
                tf.append("  volumes {")
                tf.append(f'    host_path      = "{host_path}"')
                tf.append(f'    container_path = "{container_path}"')
                tf.append("  }")
            
            # Command and entrypoint
            if device.config.entrypoint:
                tf.append(f'  entrypoint = ["{device.config.entrypoint}"]')
            if device.config.command:
                tf.append(f'  command = ["{device.config.command}"]')
            
            # Restart policy
            tf.append(f'  restart = "{device.config.restart_policy}"')
            
            # Resource limits
            if device.config.cpu_limit or device.config.memory_limit:
                # CPU shares (1024 = 1 CPU)
                if device.config.cpu_limit:
                    tf.append(f'  cpu_shares = {int(device.config.cpu_limit * 1024)}')
                
                # Memory limit
                if device.config.memory_limit:
                    mem_value = device.config.memory_limit.replace('g', '000').replace('m', '')
                    try:
                        tf.append(f'  memory = {int(mem_value)}')
                    except:
                        tf.append('  memory = 512')
            
            # Capabilities
            if device.config.capabilities:
                tf.append("  capabilities {")
                tf.append(f'    add = {device.config.capabilities}')
                tf.append("  }")
            
            # Privileged mode
            if device.config.privileged:
                tf.append('  privileged = true')
            
            # Labels
            if device.config.labels:
                tf.append("  labels {")
                for key, value in device.config.labels.items():
                    tf.append(f'    label = "{key}"')
                    tf.append(f'    value = "{value}"')
                tf.append("  }")
        
        tf.append("}")
        tf.append("")
        
        return tf
    
    @staticmethod
    def _sanitize_name(name: str) -> str:
        """Sanitize name for Terraform resource naming"""
        return name.replace('-', '_').replace('.', '_').replace(' ', '_').lower()


class DockerComposeExporter:
    """Export network configuration to Docker Compose"""
    
    @staticmethod
    def export(project: NetworkProject) -> str:
        """Generate Docker Compose YAML"""
        compose = []
        
        compose.append("# Docker Compose Configuration")
        compose.append(f"# Project: {project.name}")
        compose.append(f"# {project.description}")
        compose.append("")
        compose.append("version: '3.8'")
        compose.append("")
        compose.append("services:")
        
        # Generate service configurations
        for device in project.devices.values():
            if device.type in [DeviceType.COMPUTER, DeviceType.DATABASE]:
                compose.extend(DockerComposeExporter._generate_service(device))
        
        # Networks section
        networks = set()
        for device in project.devices.values():
            networks.update(device.networks)
        
        if networks:
            compose.append("")
            compose.append("networks:")
            for network in sorted(networks):
                compose.append(f"  {network}:")
                compose.append("    driver: bridge")
                compose.append("    ipam:")
                compose.append("      config:")
                compose.append("        - subnet: 172.20.0.0/16")
        
        # Volumes section (if any volumes are used)
        volumes = set()
        for device in project.devices.values():
            if device.config and device.config.storage_volume:
                if ':' in device.config.storage_volume:
                    volume = device.config.storage_volume.split(':')[0]
                    if not volume.startswith('.') and not volume.startswith('/'):
                        volumes.add(volume)
        
        if volumes:
            compose.append("")
            compose.append("volumes:")
            for volume in sorted(volumes):
                compose.append(f"  {volume}:")
        
        return '\n'.join(compose)
    
    @staticmethod
    def _generate_service(device: NetworkDevice) -> List[str]:
        """Generate service configuration for a device"""
        compose = []
        
        compose.append(f"  {device.name}:")
        
        # Image
        if device.config:
            if device.config.os == OSType.CUSTOM and device.config.custom_image:
                compose.append(f"    image: {device.config.custom_image}")
            else:
                compose.append(f"    image: {device.config.os.value}")
        else:
            compose.append("    image: alpine:latest")
        
        compose.append(f"    container_name: {device.name}")
        
        if device.config:
            # Command and entrypoint
            if device.config.entrypoint:
                compose.append(f"    entrypoint: {device.config.entrypoint}")
            if device.config.command:
                compose.append(f"    command: {device.config.command}")
            
            # Ports
            if device.config.ports:
                compose.append("    ports:")
                for port in device.config.ports:
                    compose.append(f'      - "{port}"')
            
            # Environment variables
            if device.config.environment_vars:
                compose.append("    environment:")
                for key, value in device.config.environment_vars.items():
                    compose.append(f"      - {key}={value}")
            
            # Volumes
            if device.config.storage_volume:
                compose.append("    volumes:")
                compose.append(f"      - {device.config.storage_volume}")
            
            # Networks with IP configuration
            if device.networks:
                compose.append("    networks:")
                for network in device.networks:
                    compose.append(f"      {network}:")
                    # Add IP configuration if available
                    if device.config.interfaces:
                        for iface in device.config.interfaces:
                            if iface.ip_address:
                                compose.append(f"        ipv4_address: {iface.ip_address}")
                                break
            
            # Resource limits
            if device.config.cpu_limit or device.config.memory_limit:
                compose.append("    deploy:")
                compose.append("      resources:")
                compose.append("        limits:")
                if device.config.cpu_limit:
                    compose.append(f"          cpus: '{device.config.cpu_limit}'")
                if device.config.memory_limit:
                    compose.append(f"          memory: {device.config.memory_limit}")
            
            # Restart policy
            compose.append(f"    restart: {device.config.restart_policy}")
            
            # Privileged mode
            if device.config.privileged:
                compose.append("    privileged: true")
            
            # Capabilities
            if device.config.capabilities:
                compose.append("    cap_add:")
                for cap in device.config.capabilities:
                    compose.append(f"      - {cap}")
            
            # Labels
            if device.config.labels:
                compose.append("    labels:")
                for key, value in device.config.labels.items():
                    compose.append(f'      - "{key}={value}"')
        
        compose.append("")
        return compose


class SVGExporter:
    """Export network diagram to SVG"""
    
    @staticmethod
    def export(canvas_widget, filename: str):
        """Export the network diagram to SVG file"""
        # Create SVG root
        width = int(canvas_widget.width) if canvas_widget.width > 0 else 1200
        height = int(canvas_widget.height) if canvas_widget.height > 0 else 800
        
        svg = ET.Element('svg', {
            'width': str(width),
            'height': str(height),
            'xmlns': 'http://www.w3.org/2000/svg',
            'xmlns:xlink': 'http://www.w3.org/1999/xlink',
            'viewBox': f'0 0 {width} {height}'
        })
        
        # Add styles
        defs = ET.SubElement(svg, 'defs')
        style = ET.SubElement(defs, 'style', {'type': 'text/css'})
        style.text = """
            .device-label { font-family: Arial, sans-serif; font-size: 12px; fill: #333; }
            .connection-line { stroke: #666; stroke-width: 2; fill: none; }
            .device-computer { fill: #4d7fc7; }
            .device-router { fill: #4db34d; }
            .device-switch { fill: #b3b34d; }
            .device-firewall { fill: #cc4d4d; }
            .device-database { fill: #9966cc; }
            .device-loadbalancer { fill: #66b3b3; }
            .interface-active { fill: #33cc33; }
            .interface-inactive { fill: #999999; }
        """
        
        # Add gradient definitions
        SVGExporter._add_gradients(defs)
        
        # Background
        ET.SubElement(svg, 'rect', {
            'width': str(width),
            'height': str(height),
            'fill': '#f5f5f5'
        })
        
        # Grid pattern
        SVGExporter._add_grid_pattern(defs)
        ET.SubElement(svg, 'rect', {
            'width': str(width),
            'height': str(height),
            'fill': 'url(#grid-pattern)',
            'opacity': '0.3'
        })
        
        # Draw connections
        connections_group = ET.SubElement(svg, 'g', {'id': 'connections'})
        for conn in canvas_widget.connections.values():
            if conn.source_id in canvas_widget.device_widgets and conn.target_id in canvas_widget.device_widgets:
                source = canvas_widget.device_widgets[conn.source_id]
                target = canvas_widget.device_widgets[conn.target_id]
                
                # Calculate connection points
                sx = source.x + source.width/2
                sy = height - (source.y + source.height/2)
                tx = target.x + target.width/2
                ty = height - (target.y + target.height/2)
                
                # Draw curved connection for better visibility
                mx = (sx + tx) / 2
                my = (sy + ty) / 2
                
                path = ET.SubElement(connections_group, 'path', {
                    'd': f'M {sx} {sy} Q {mx} {my - 20} {tx} {ty}',
                    'class': 'connection-line',
                    'stroke-dasharray': '5,3' if conn.bandwidth else 'none'
                })
                
                # Add connection endpoints
                ET.SubElement(connections_group, 'circle', {
                    'cx': str(sx),
                    'cy': str(sy),
                    'r': '4',
                    'fill': '#4d7fc7'
                })
                ET.SubElement(connections_group, 'circle', {
                    'cx': str(tx),
                    'cy': str(ty),
                    'r': '4',
                    'fill': '#4d7fc7'
                })
        
        # Draw devices
        devices_group = ET.SubElement(svg, 'g', {'id': 'devices'})
        for device_id, widget in canvas_widget.device_widgets.items():
            device = widget.device
            
            # Device group
            device_g = ET.SubElement(devices_group, 'g', {
                'id': f'device_{device_id}',
                'transform': f'translate({widget.x}, {height - widget.y - widget.height})'
            })
            
            # Device shape based on type
            SVGExporter._draw_device_shape(device_g, device, widget)
            
            # Device label
            ET.SubElement(device_g, 'text', {
                'x': str(widget.width/2),
                'y': str(widget.height + 15),
                'text-anchor': 'middle',
                'class': 'device-label'
            }).text = device.name
            
            # Network interfaces
            if device.config and device.config.interfaces:
                SVGExporter._draw_interfaces(device_g, device, widget)
        
        # Add legend
        SVGExporter._add_legend(svg, width, height)
        
        # Write to file
        tree = ET.ElementTree(svg)
        tree.write(filename, encoding='utf-8', xml_declaration=True)
        
        # Pretty print
        SVGExporter._prettify_svg(filename)
    
    @staticmethod
    def _add_gradients(defs):
        """Add gradient definitions"""
        gradients = [
            ('computer-gradient', '#4d7fc7', '#3a5f94'),
            ('router-gradient', '#4db34d', '#3a863a'),
            ('switch-gradient', '#b3b34d', '#86863a'),
            ('firewall-gradient', '#cc4d4d', '#993a3a'),
            ('database-gradient', '#9966cc', '#734d99'),
            ('loadbalancer-gradient', '#66b3b3', '#4d8686')
        ]
        
        for grad_id, color1, color2 in gradients:
            gradient = ET.SubElement(defs, 'linearGradient', {
                'id': grad_id,
                'x1': '0%',
                'y1': '0%',
                'x2': '0%',
                'y2': '100%'
            })
            ET.SubElement(gradient, 'stop', {
                'offset': '0%',
                'style': f'stop-color:{color1};stop-opacity:1'
            })
            ET.SubElement(gradient, 'stop', {
                'offset': '100%',
                'style': f'stop-color:{color2};stop-opacity:1'
            })
    
    @staticmethod
    def _add_grid_pattern(defs):
        """Add grid pattern"""
        pattern = ET.SubElement(defs, 'pattern', {
            'id': 'grid-pattern',
            'width': '50',
            'height': '50',
            'patternUnits': 'userSpaceOnUse'
        })
        ET.SubElement(pattern, 'line', {
            'x1': '0',
            'y1': '0',
            'x2': '50',
            'y2': '0',
            'stroke': '#ddd',
            'stroke-width': '0.5'
        })
        ET.SubElement(pattern, 'line', {
            'x1': '0',
            'y1': '0',
            'x2': '0',
            'y2': '50',
            'stroke': '#ddd',
            'stroke-width': '0.5'
        })
    
    @staticmethod
    def _draw_device_shape(group, device, widget):
        """Draw device shape in SVG"""
        shape_map = {
            DeviceType.COMPUTER: SVGExporter._draw_computer,
            DeviceType.ROUTER: SVGExporter._draw_router,
            DeviceType.SWITCH: SVGExporter._draw_switch,
            DeviceType.FIREWALL: SVGExporter._draw_firewall,
            DeviceType.DATABASE: SVGExporter._draw_database,
            DeviceType.LOADBALANCER: SVGExporter._draw_loadbalancer
        }
        
        draw_func = shape_map.get(device.type, SVGExporter._draw_computer)
        draw_func(group, widget)
    
    @staticmethod
    def _draw_computer(group, widget):
        """Draw computer shape"""
        # Monitor
        ET.SubElement(group, 'rect', {
            'x': '20',
            'y': '20',
            'width': '50',
            'height': '35',
            'rx': '3',
            'fill': 'url(#computer-gradient)',
            'stroke': '#2a4a6a',
            'stroke-width': '2'
        })
        # Screen
        ET.SubElement(group, 'rect', {
            'x': '25',
            'y': '25',
            'width': '40',
            'height': '25',
            'fill': '#1a2a3a'
        })
        # Base
        ET.SubElement(group, 'rect', {
            'x': '35',
            'y': '55',
            'width': '20',
            'height': '8',
            'fill': '#666'
        })
    
    @staticmethod
    def _draw_router(group, widget):
        """Draw router shape"""
        # Diamond
        ET.SubElement(group, 'polygon', {
            'points': '45,15 70,40 45,65 20,40',
            'fill': 'url(#router-gradient)',
            'stroke': '#2a6a2a',
            'stroke-width': '2'
        })
        # Antenna
        ET.SubElement(group, 'line', {
            'x1': '35',
            'y1': '15',
            'x2': '30',
            'y2': '5',
            'stroke': '#333',
            'stroke-width': '2'
        })
        ET.SubElement(group, 'line', {
            'x1': '55',
            'y1': '15',
            'x2': '60',
            'y2': '5',
            'stroke': '#333',
            'stroke-width': '2'
        })
    
    @staticmethod
    def _draw_switch(group, widget):
        """Draw switch shape"""
        # Main body
        ET.SubElement(group, 'rect', {
            'x': '15',
            'y': '30',
            'width': '60',
            'height': '30',
            'rx': '3',
            'fill': 'url(#switch-gradient)',
            'stroke': '#6a6a2a',
            'stroke-width': '2'
        })
        # Ports
        for i in range(4):
            ET.SubElement(group, 'rect', {
                'x': str(20 + i*13),
                'y': '35',
                'width': '8',
                'height': '6',
                'fill': '#333'
            })
            ET.SubElement(group, 'rect', {
                'x': str(20 + i*13),
                'y': '49',
                'width': '8',
                'height': '6',
                'fill': '#333'
            })
    
    @staticmethod
    def _draw_firewall(group, widget):
        """Draw firewall shape"""
        # Shield
        ET.SubElement(group, 'path', {
            'd': 'M 45 15 L 65 25 L 65 45 L 45 65 L 25 45 L 25 25 Z',
            'fill': 'url(#firewall-gradient)',
            'stroke': '#6a2a2a',
            'stroke-width': '2'
        })
        # Lock icon
        ET.SubElement(group, 'circle', {
            'cx': '45',
            'cy': '40',
            'r': '8',
            'fill': '#fff',
            'opacity': '0.8'
        })
    
    @staticmethod
    def _draw_database(group, widget):
        """Draw database shape"""
        # Top ellipse
        ET.SubElement(group, 'ellipse', {
            'cx': '45',
            'cy': '25',
            'rx': '20',
            'ry': '8',
            'fill': 'url(#database-gradient)',
            'stroke': '#4a2a6a',
            'stroke-width': '2'
        })
        # Body
        ET.SubElement(group, 'rect', {
            'x': '25',
            'y': '25',
            'width': '40',
            'height': '30',
            'fill': 'url(#database-gradient)'
        })
        # Bottom ellipse
        ET.SubElement(group, 'ellipse', {
            'cx': '45',
            'cy': '55',
            'rx': '20',
            'ry': '8',
            'fill': 'url(#database-gradient)',
            'stroke': '#4a2a6a',
            'stroke-width': '2'
        })
    
    @staticmethod
    def _draw_loadbalancer(group, widget):
        """Draw load balancer shape"""
        # Circle
        ET.SubElement(group, 'circle', {
            'cx': '45',
            'cy': '45',
            'r': '25',
            'fill': 'url(#loadbalancer-gradient)',
            'stroke': '#2a6a6a',
            'stroke-width': '2'
        })
        # Arrows
        ET.SubElement(group, 'path', {
            'd': 'M 30 45 L 60 45 M 55 40 L 60 45 L 55 50',
            'stroke': '#fff',
            'stroke-width': '2',
            'fill': 'none'
        })
    
    @staticmethod
    def _draw_interfaces(group, device, widget):
        """Draw network interfaces"""
        interfaces_g = ET.SubElement(group, 'g', {'id': 'interfaces'})
        
        for i, iface in enumerate(device.config.interfaces[:4]):  # Max 4 visible
            x = 15 + i * 20
            y = widget.height - 10
            
            # Interface indicator
            ET.SubElement(interfaces_g, 'circle', {
                'cx': str(x),
                'cy': str(y),
                'r': '4',
                'class': 'interface-active' if iface.ip_address else 'interface-inactive',
                'title': f'{iface.name}: {iface.ip_address or "Not configured"}'
            })
            
            # Interface label
            if iface.ip_address:
                ET.SubElement(interfaces_g, 'text', {
                    'x': str(x),
                    'y': str(y + 12),
                    'font-size': '8',
                    'text-anchor': 'middle',
                    'fill': '#666'
                }).text = iface.name
    
    @staticmethod
    def _add_legend(svg, width, height):
        """Add legend to SVG"""
        legend_g = ET.SubElement(svg, 'g', {
            'id': 'legend',
            'transform': f'translate({width - 150}, 20)'
        })
        
        # Background
        ET.SubElement(legend_g, 'rect', {
            'x': '0',
            'y': '0',
            'width': '140',
            'height': '180',
            'fill': '#fff',
            'stroke': '#ccc',
            'stroke-width': '1',
            'rx': '5',
            'opacity': '0.9'
        })
        
        # Title
        ET.SubElement(legend_g, 'text', {
            'x': '70',
            'y': '20',
            'text-anchor': 'middle',
            'font-weight': 'bold',
            'font-size': '12'
        }).text = 'Legend'
        
        # Device types
        device_types = [
            (DeviceType.COMPUTER, '#4d7fc7', 'Computer'),
            (DeviceType.ROUTER, '#4db34d', 'Router'),
            (DeviceType.SWITCH, '#b3b34d', 'Switch'),
            (DeviceType.FIREWALL, '#cc4d4d', 'Firewall'),
            (DeviceType.DATABASE, '#9966cc', 'Database'),
            (DeviceType.LOADBALANCER, '#66b3b3', 'Load Balancer')
        ]
        
        for i, (device_type, color, label) in enumerate(device_types):
            y = 40 + i * 20
            
            # Icon
            ET.SubElement(legend_g, 'rect', {
                'x': '10',
                'y': str(y - 5),
                'width': '10',
                'height': '10',
                'fill': color,
                'rx': '2'
            })
            
            # Label
            ET.SubElement(legend_g, 'text', {
                'x': '25',
                'y': str(y + 3),
                'font-size': '10'
            }).text = label
    
    @staticmethod
    def _prettify_svg(filename):
        """Pretty print SVG file"""
        try:
            with open(filename, 'r') as f:
                xml_str = f.read()
            
            dom = minidom.parseString(xml_str)
            pretty_xml = dom.toprettyxml(indent="  ")
            
            # Remove extra blank lines
            lines = [line for line in pretty_xml.split('\n') if line.strip()]
            pretty_xml = '\n'.join(lines)
            
            with open(filename, 'w') as f:
                f.write(pretty_xml)
        except Exception as e:
            print(f"Warning: Could not prettify SVG: {e}")